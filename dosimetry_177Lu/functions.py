#basic functions

import numpy as np
from pytomography.io.SPECT import simind
import nibabel as nib
import torch
import matplotlib.pyplot as plt 
import ipywidgets
import scienceplots
import csv
import SimpleITK as sitk
from pytomography.projectors.SPECT import SPECTSystemMatrix
from pytomography.transforms.SPECT import SPECTAttenuationTransform, SPECTPSFTransform
from pytomography.algorithms import OSEM
from pytomography.likelihoods import PoissonLogLikelihood
from pytomography.metadata.SPECT import SPECTPSFMeta


"""
This file contains basic functions created to handle SIMIND output files.

Reconstruction of the projections with scatter, attenuation and PSF correction is done in the recon function. 

Some useful functions like read_dicom and save_dicom are also provided, for easy and practical manipulation
of outside DICOM images (if needed).

"""



def export_nii(np_array, output_path:str, pixel:float=None, header=None):

    """
    Export a numpy array to a nifti file

    Args: 
    - header: .h00 path file
    - np_array: numpy array/torch tensor to export
    - output_path: path to the exporting file

    """

    if pixel==None:
        pixel_size= ((simind.get_metadata(header))[0].dr)[0]*10 
    else:
        pixel_size= pixel

    affine_matrix= np.array([[pixel_size, 0,  0,  0],
                            [0,  pixel_size, 0,  0],
                            [0,  0,  pixel_size, 0],
                            [0,  0,  0,  1]])
    
    if torch.is_tensor(np_array): 
        np_array= np_array.cpu().numpy()
    
    try:   
        image= np.rot90(np_array, k=2)  
        image = np.flip(image, axis=2)
        nifti_file = nib.Nifti1Image(image, affine=affine_matrix)
        nib.save(nifti_file, output_path)
        print("Volume saved in:", output_path)

    except Exception as e:
        print(f"Error saving NIfTI file: {e}")

def ct(file_path:str, num_slices:int, position=2, cmap='Greys_r'):
    """
    Plots the attenuation map generated by SIMIND

    Args:
    - ct_path (str): caminho do ficheiro .hct
    - num_slices (int): number of simulated slices (usually the number of projections)
    - position (int) (0,1,2): axis to be visualized

    Returns:
    - CT attenuation map (torch)
    
    """
    ct= simind.get_attenuation_map(file_path)

    if cmap != None: 
        def plot(slice_p): 
            cmap='Greys_r'
            label= 'Attenuation Coefficient'
            title= 'CT'
            if position==0:
                plt.pcolormesh(torch.rot90(ct, k=2, dims=(1, 2))[slice_p,:,:].T, cmap=cmap)
            elif position==1:
                plt.pcolormesh(torch.rot90(ct, k=2, dims=(0, 2))[:,slice_p,:].T, cmap=cmap)
            else:
                plt.pcolormesh(torch.rot90(ct, k=2, dims=(0, 1))[:,:,slice_p].T, cmap=cmap)
            
            cbar = plt.colorbar(label=label)
            plt.title(title, fontsize=14) 
            plt.axis()
            plt.show()

        ipywidgets.interact(plot, slice_p=ipywidgets.IntSlider(min=0, max=(num_slices-1), 
                        step=1, value=0, continuous_update=False))
    
    return ct 
    
def projections(file_path:str, num_projections:int, time:int, activity:int=1, cmap='gray'):

    """
    Allows de visualization of the projections obtained with SIMIND.

    Args:
    - file_path (str): .h00 (header) file path
    - num_projections (int): number of simulated SPECT projections
    - time (int): time per projection
    - activity (int) (default=1): activity to simulate (if not already done in the simulation)
    
    Returns:
    - unscaled projections (torch)
    - real scaled projections (torch)
    
    """
    proj= simind.get_projections(file_path)   
    proj = torch.clamp(proj, min=1e-6) 
    real_spect= torch.poisson(proj*activity*time) 


    if cmap != None:   
        def plot(slice_p):
            cmap='inferno'
            label= 'Counts'
            title='SPECT'
            plt.imshow(real_spect[slice_p].T, cmap=cmap) 
            cbar = plt.colorbar(label=label)
            plt.title(title, fontsize=14) 
            plt.axis()
            plt.show()

        ipywidgets.interact(plot, slice_p=ipywidgets.IntSlider(min=0, max=(num_projections-1), 
                        step=1, value=0, continuous_update=False))

    return proj, real_spect

def plot_spectra(isotope:str, tot:str ,pri:str=None,sca:str=None):

    """
    Plots the energy spectrum for the simulation.

    Args:
    - isotope (str): 'lu' ou 'tc'
    - tot (str): .spe path for the total spectra file
    - pri (str): .spe path for the primary spectra file
    - sca (str): .spe path for the scatter spectra file

    """
    if isotope=='lu':
        photopeak= 140.5
    else:
        photopeak= 208

    lista= [tot, pri, sca]
    if pri ==None or sca== None:
        lista= [tot]

    for name in lista:
        energia = []
        contagens = []
        with open(name, 'r') as file:
            reader = csv.reader(file, delimiter='N')
            for row in reader:
                    energia.append(float(row[0])*0.25) #0.25KeV/channel
                    contagens.append(float(row[1]))
        with plt.style.context(['science', 'notebook']):
            plt.plot(energia, contagens)

        plt.xlabel('Energy (keV)')
        plt.ylabel('Counts/sec')
        plt.vlines(x=photopeak, ymin=0, ymax=30000, colors='gray', linestyles="dashed")
        plt.show()

def scatter_estimation(photopeak_path:str, lower_path:str, upper_path=None, weight=None, time=None, activity=1):

    """
    Recebe:
    - photopeak_path (str): .h00 path to photopeak
    - lower_path (str): .h00 path to lower energy window
    - upper_path (str): .h00 path to upper energy window
    - weight (int): weight for DEW method
    - time (int): time per projection
    - activity (int): defaulted to 1
     
    Devolve:
    - scatter estimation (torch tensor)
    """

    lower_width= simind.get_energy_window_width(lower_path)
    print('lower window width:', lower_width)
    lower_projection= simind.get_projections(lower_path)
    
    photopeak_width= simind.get_energy_window_width(photopeak_path)
    print('photopeak window width:', photopeak_width)

    if upper_path !=None: 
            upper_width= simind.get_energy_window_width(upper_path)
            print('upper window width:', upper_width)
            upper_projection= simind.get_projections(upper_path)
            estimated_scatter= simind.compute_EW_scatter(lower_projection, upper_projection, 
                                             lower_width, upper_width, photopeak_width)
            print('calculating scatter via TEW..')
    else: 
        print('calculating scatter via DEW..')
        if weight== None:
            print('No weight given, 0.5 will be used')
            weight=0.5
        else:
            weight= weight
        
        estimated_scatter= (weight*lower_projection)  

    if time==None:
        rescaled_scatter= estimated_scatter
        print('returned unscaled scatter estimation')
    
    else: 
        estimated_scatter = torch.clamp(estimated_scatter, min=0.0) 
        rescaled_scatter= torch.poisson(estimated_scatter*time*activity)
        print('returned scaled scatter with poisson noise')

    return rescaled_scatter

def recon(projections: torch.tensor , att_map: torch.tensor, header_path:str, iterations:int, subsets:int, scatter:torch.tensor):

    """
    SPECT reconstruction via OSEM algorithm

    Recebe:
    - projections (torch tensor): real projections
    - att_map (torch tensor): attenuation map
    - header_path (str): .h00 file path
    - scatter (torch tensor): scatter estimation (previously scaled)
    - iterations (int)
    - subsets (int)

    Devolve:
    - reconstructed spect (torch)
    """

    object_meta, proj_meta= simind.get_metadata(header_path)
    att_transform= SPECTAttenuationTransform(att_map)

    psf_meta = simind.get_psfmeta_from_header(header_path, min_sigmas=3)
    psf_transform = SPECTPSFTransform(psf_meta)

    system_matrix= SPECTSystemMatrix(
        obj2obj_transforms = [att_transform, psf_transform],
        proj2proj_transforms=[],
        object_meta= object_meta,
        proj_meta=proj_meta
    )

    likelihood= PoissonLogLikelihood(system_matrix=system_matrix,
                                    projections=projections,
                                    additive_term=scatter)
    
    recon_algorithm= OSEM(likelihood)
    reconstructed_spect= recon_algorithm(n_iters=iterations, n_subsets=subsets)

    return reconstructed_spect

def calib(header_path:str, ct_path:str, lower_path:str, time:int, iterations:int, subsets:int, scatter_weight:float, activity:float):

    """
    Calibration via water cylinder (128 projections)

    Recebe:
    - header_path (str): path to the cylinder projections
    - ct_path (str): path to the cylinder ct
    - lower_path (str): lower path to the cylinder projections
    - time (int): time per projection
    - iterations (int)
    - subsets (int)
    - scatter weight (int): 

    Devolve:
    - calibration factor (float): in cps/MBq

    """

    true_activity= activity
    time_per_projection= time

    spect, real_spect= projections(header_path, 128, time= time_per_projection, 
                                   activity=1, cmap=None)
    
    ct_image= ct(ct_path, 128, cmap=None)

    scatter= scatter_estimation(header_path, lower_path, upper_path=None,
                                weight= scatter_weight, time= time_per_projection)
    
    recon_cyl= recon(real_spect, ct_image, header_path , iterations= iterations, subsets= subsets,
                     scatter= scatter)
    
    calib_factor= recon_cyl.sum().item()/(128*time_per_projection*true_activity)
    print('calibration factor:', calib_factor, 'cps/MBq')

    return calib_factor

def read_dicom(path:str):
    """
    reads a DICOM image.

    Args:
        path (str): path to the dicom image (in .nnrd or .nii or compatible sitk formats)

    Returns: 
        sitk image
    """
    reader = sitk.ImageFileReader()
    reader.SetFileName(path)
    image = reader.Execute()

    return image

def save_dicom(original_image, array:np.array, path:str):

    """
    original_image (sitk image): to copy the original information
    array (np array): array to convert to an image
    path: output path to save the image

    """
    
    final_image= sitk.GetImageFromArray(array)

    final_image.SetSpacing(original_image.GetSpacing())    
    final_image.SetOrigin(original_image.GetOrigin())

    final_image.SetDirection(original_image.GetDirection())
    sitk.WriteImage(final_image, path)

    print('image saved in:', path)


